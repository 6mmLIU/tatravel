### 1. 全文检索

在此项目中，全文检索功能位于 `travel-modules-business` 下的 `travel-modules-search` 模块。该模块基于 Spring Data Elasticsearch 与多个业务微服务的远程调用，实现了“将关键字一次性搜索多个业务域（攻略、游记、用户、目的地）并支持高亮展示”的需求。关键流程可分为：构建查询对象、设置高亮字段、执行查询并解析结果、再与真实业务数据进行整合。下面是核心实现的节选并附上详细注释：

```java
// SearchServiceImpl.searchHighLight 核心逻辑
public <T> Page<T> searchHighLight(
        Class<T> clazz,           // 目标实体类（MySQL中的实体）
        Class<?> esClazz,         // ES索引对应的实体类
        SearchQuery qo,           // 包含关键字、分页参数等信息的查询对象
        String... fields          // 需要匹配并高亮的字段
) throws InvocationTargetException, IllegalAccessException {

    // 1. 构建查询：multiMatchQuery 会在多个字段上匹配关键字
    builder.withQuery(
        QueryBuilders.multiMatchQuery(qo.getKeyword(), fields)
    );

    // 2. 设置分页信息
    Pageable pageable = PageRequest.of(qo.getCurrentPage() - 1, qo.getPageSize());
    builder.withPageable(pageable);

    // 3. 构造高亮字段配置，可对多个字段设置同样的 preTags/postTags
    for (String field : fields) {
        HighlightBuilder.Field highlightField = new HighlightBuilder.Field(field)
                .preTags("<span style='color:red'>")  // 高亮前缀
                .postTags("</span>");                 // 高亮后缀
        highlightFields.add(highlightField);
    }
    builder.withHighlightFields(highlightFields);

    // 4. 执行查询并获取 SearchHits
    SearchHits<?> hits = template.search(builder.build(), esClazz);
    long total = hits.getTotalHits();

    // 5. 遍历命中结果，先取出 ES 返回的文档 id，然后通过远程服务到 MySQL 查询真实对象
    for (SearchHit<?> hit : hits.getSearchHits()) {
        Long id = Long.valueOf(hit.getId());
        T t = null;
        if (Strategy.class == clazz) {
            t = (T) remoteStrategyService.getOne(id, SecurityConstants.INNER).getData();
        } else if (Note.class == clazz) {
            t = (T) remoteNoteService.getOne(id, SecurityConstants.INNER).getData();
        } // ...其他类型省略

        // 6. 将高亮字段值写回到真实对象中
        Map<String, List<String>> map = hit.getHighlightFields();
        for (String key : map.keySet()) {
            List<String> list = map.get(key);
            StringBuffer sb = new StringBuffer();
            for (String s : list) { sb.append(s + " "); }
            BeanUtils.setProperty(t, key, sb.toString());  // BeanUtils 反射写入属性
        }
        content.add(t);
    }
    return new PageImpl<T>(content, pageable, total); // 返回分页结果
}
```

这一套流程确保了搜索与高亮逻辑在 ES 层完成，而最终呈现给用户的对象仍然来自各个业务服务的数据库表。这样既能利用 ES 的全文索引能力，又能确保数据的一致性与丰富性。项目中 `SearchController` 会根据不同搜索类型调用上述方法，从而组合不同的搜索结果。例如 `searchAll` 会分别检索用户、攻略、游记、目的地，将结果分页后合并为 `Map` 返回给前端。

为了保证服务独立与可维护性，各业务实体（如 `UserInfoES`、`StrategyES` 等）均以独立的 ES 索引存在。系统通过 `ElasticsearchRestTemplate` 进行交互，使用 `multiMatchQuery` 实现跨字段搜索，使用 `HighlightBuilder` 设置高亮标签，前端展示时可直接呈现带 `<span>` 标签的富文本内容。此外，在解析 `SearchHits` 时通过 id 反查数据库，避免了 ES 与 MySQL 数据不一致导致的问题。该策略还使得 ES 索引仅需存储轻量的冗余字段，大部分详细信息仍通过微服务远程获取。

从扩展性考虑，`ISearchService.searchHighLight` 采用泛型与可变参数设计，可对任意实体、任意字段复用该搜索逻辑。未来如需增加新的搜索类型，只需新增 ES 映射实体及对应远程服务，无需改动核心逻辑。由此可见，这一全文检索方案充分利用了 ES 的高性能查询能力，并结合微服务框架实现了跨域聚合搜索与高亮展示，较好地满足了旅行平台多维搜索的业务诉求。

### 2. 高并发统计数字（浏览量、评论量等）

高并发的统计需求在该项目中主要体现在攻略（Strategy）等内容的浏览量、评论量、收藏量等数字的实时累计与展示。为了避免直接写库导致的性能瓶颈和锁竞争，系统采用 Redis 作为中间层，以哈希结构缓存统计字段，提供原子递增操作，并定期将缓存数据持久化回数据库。核心逻辑位于 `travel-modules-business` 下的 `travel-modules-strategy` 模块。以下摘录了 `StrategyServiceImpl` 的部分关键代码并附加中文注释：

```java
// 统计数据初始化：若 Redis 中不存在该攻略的统计数据，则从 MySQL 加载
private String strategyHashInit(Long sid) {
    // 拼接 key，形如 strategy_status_hash:sid
    String key = RedisKeys.STRATEGY_STATUS_HASH.join(sid.toString());
    if (!redisService.hasKey(key)) {              // 若 Redis 中不存在该 key
        Strategy strategy = baseMapper.selectById(sid); // 查询数据库
        Map map = new HashMap();
        map.put("id", strategy.getId());
        map.put("viewnum", Integer.valueOf(strategy.getViewnum().toString()));
        map.put("replynum", Integer.valueOf(strategy.getReplynum().toString()));
        map.put("favornum", Integer.valueOf(strategy.getFavornum().toString()));
        map.put("sharenum", Integer.valueOf(strategy.getSharenum().toString()));
        map.put("thumbsupnum", Integer.valueOf(strategy.getThumbsupnum().toString()));
        redisService.setCacheMap(key, map);       // 将数据写入 Redis Hash
    }
    return key;
}

// 浏览量增加：每次阅读都会调用，原子自增并返回最新统计
public Map viewnumIncrease(Long sid) {
    String key = strategyHashInit(sid);           // 确保 Redis 中有基础数据
    redisService.incrementCacheMapValue(key, "viewnum", 1); // 原子自增浏览量
    return redisService.getCacheMap(key);         // 返回最新统计
}

// 评论量增加：评论成功后调用，逻辑与浏览量类似
public Map replynumIncr(Long sid) {
    String key = strategyHashInit(sid);
    redisService.incrementCacheMapValue(key, "replynum", 1);
    return redisService.getCacheMap(key);
}

// 收藏、点赞等操作也基于 Redis 原子操作实现
public Map favor(Long sid, Long userId) {
    String key = RedisKeys.STRATEGY_USER_FAVOR.join(userId.toString());
    if (!redisService.hasKey(key)) {
        Set<Long> sids = new HashSet<>();
        sids.add(-1l);              // 设置哨兵值 -1，避免空集合问题
        redisService.setCacheSet(key, sids);
    }
    String hashKey = RedisKeys.STRATEGY_STATUS_HASH.join(sid.toString());
    boolean result = false;
    if (redisService.isCacheSetContains(key, sid)) {
        redisService.incrementCacheMapValue(hashKey, "favornum", -1); // 已收藏则取消
        redisService.deleteCacheSetValue(key, sid);
    } else {
        redisService.incrementCacheMapValue(hashKey, "favornum", +1); // 未收藏则添加
        redisService.addCacheSetValue(key, sid);
        result = true;
    }
    Map<String, Object> cacheMap = redisService.getCacheMap(hashKey);
    cacheMap.put("result", result);
    return cacheMap;
}
```

上述实现具备以下特点：

1. **Redis 哈希结构缓存**：每篇攻略对应一个形如 `strategy_status_hash:<sid>` 的 Hash，内部字段包括浏览量 `viewnum`、评论量 `replynum` 等。使用 Hash 能在一个 key 中管理多种统计指标，降低 Redis 的键数量。
2. **原子递增保证线程安全**：`incrementCacheMapValue` 与 `incrementCacheObjectValue` 等方法封装了 Redis 的 `HINCRBY` 或 `INCR` 指令，在高并发场景下仍然保持准确的累加效果，避免锁竞争。
3. **延迟持久化**：`statisHashPersistence` 方法会定期从 Redis 扫描所有以 `strategy_status_hash:*` 开头的 key，并将其中的统计数据批量更新到 MySQL。此过程可由定时任务触发，或者在某些事件（例如系统空闲时）执行，实现“缓存先行、异步落库”的模式。
4. **多维统计**：除了浏览与评论，代码还处理收藏、点赞、分享等行为。比如 `favor` 方法通过 Redis Set 记录用户收藏过的攻略，减少数据库关联查询，同时实现收藏数的原子增减；`thumbsup` 方法限制每天点赞次数，通过设置带过期时间的 Redis key (`strategy_user_thumbsup`) 来控制频率。
5. **高并发读写**：前端展示统计数据直接从 Redis 读取，避免频繁访问数据库。当 Redis 中存在统计值时，无需访问 MySQL；只有首次访问或缓存失效时才会执行 `strategyHashInit` 从数据库加载。这种读写分离策略在访问量很大时能够显著减轻数据库压力。

整体而言，该模块利用 Redis 的高并发特性与丰富的数据结构（Hash、Set 等），实现了各项指标在高流量下的快速累积与实时展示。同时，通过定时持久化机制确保数据最终一致性，兼顾了性能与准确性。该方案适用于各种需要“实时统计 + 异步落库”的业务场景。

### 3. JWT

JWT（JSON Web Token）在本项目中承担了“身份认证与授权”的核心角色。整体方案分为：JWT 的生成与解析、与 Redis 结合的会话管理、网关过滤器对请求的校验，以及业务服务对 Token 的使用。相关代码主要分布在 `travel-common` 的 `core` 与 `security` 模块，以及 `travel-gateway` 网关工程和 `travel-auth` 认证服务。以下从工具类、服务类与过滤器三个角度展开说明。

#### 3.1 JwtUtils：生成与解析令牌

`travel-common-core` 模块中的 `JwtUtils` 封装了对 `io.jsonwebtoken` 的操作。其 `createToken` 方法接受一个存放用户信息的 `Map`，使用 `HS512` 算法对数据进行签名生成字符串形式的 Token；`parseToken` 方法则用于解析 Token 并返回 `Claims` 对象。为了方便取值，还提供了 `getUserKey`、`getUserId`、`getUserName` 等方法封装对 `Claims` 的读取。示例：

```
public static String createToken(Map<String, Object> claims) {
    // 使用指定的 secret 和 HS512 算法生成 token
    return Jwts.builder().setClaims(claims)
            .signWith(SignatureAlgorithm.HS512, secret).compact();
}

public static Claims parseToken(String token) {
    // 通过同样的 secret 解析 token，返回 Claims
    return Jwts.parser().setSigningKey(secret)
            .parseClaimsJws(token).getBody();
}
```

#### 3.2 TokenService：与 Redis 结合的会话管理

`travel-common-security` 模块中的 `TokenService` 负责整个登录会话的生命周期管理。`createToken` 方法在用户登录成功后生成一个随机 `token`（UUID 形式），并把 `token` 与 `用户ID、用户名` 等信息以 `LoginUser` 对象形式缓存到 Redis。然后把 `userKey`、`userId`、`userName` 放入 `claimsMap` 调用 `JwtUtils.createToken` 生成 JWT，并把生成的 JWT 与过期时间返回给前端。后续所有请求都需要携带该 JWT。

```java
public Map<String, Object> createToken(LoginUser loginUser) {
    String token = IdUtils.fastUUID();           // 生成随机 token
    loginUser.setToken(token);
    loginUser.setIpaddr(IpUtils.getIpAddr());   // 记录登录 IP
    refreshToken(loginUser);                    // 将 LoginUser 写入 Redis 并设置过期

    // 封装要写入 JWT 的数据
    Map<String, Object> claimsMap = new HashMap<>();
    claimsMap.put(SecurityConstants.USER_KEY, token);
    claimsMap.put(SecurityConstants.DETAILS_USER_ID, loginUser.getUserid());
    claimsMap.put(SecurityConstants.DETAILS_USERNAME, loginUser.getUsername());

    Map<String, Object> rspMap = new HashMap<>();
    rspMap.put("access_token", JwtUtils.createToken(claimsMap)); // 生成 JWT
    rspMap.put("expires_in", expireTime);                       // 过期时间
    return rspMap;
}
```

`getLoginUser` 则会解析请求头中的 JWT，取出 `userkey`（即上面随机生成的 token），再到 Redis 查找对应的 `LoginUser`。为了保持会话活性，`verifyToken` 会在 Token 即将过期时刷新 Redis 中的缓存时间。这样，JWT 本身只存储了最少的信息（token、userid、username），具体的权限、角色等复杂信息都存储在 Redis 中，从而实现可控的会话管理与即时吊销。

#### 3.3 AuthFilter：网关层的统一校验

在 `travel-gateway` 工程中，`AuthFilter` 作为 Spring Cloud Gateway 的过滤器，在请求进入后端服务前解析并校验 JWT。它从请求头中取出 `Authorization` 字段，如果没有或格式不正确则直接拦截。若存在 Token，调用 `JwtUtils.parseToken` 解析并获取用户信息，再将用户 id、用户名等写入请求头传递给下游服务，使得后续业务微服务能获取到身份信息。若解析失败或 Token 过期，则返回未授权错误。

#### 3.4 TokenController：认证服务的对接

`travel-auth` 模块中的 `TokenController` 为前端提供登录接口。用户登录后，`TokenController` 会调用 `SysLoginService` 进行密码校验等操作，得到 `LoginUser` 对象，再调用前述的 `TokenService.createToken` 生成 JWT 返回给客户端。在需要刷新 Token 或登出时，也由该控制器转发到相应服务。

通过上述设计，JWT 仅作为一个自包含的身份凭证，用于在网关层快速验证用户身份，而更详细的会话信息仍存储于 Redis。该模式的优点在于：

1. **无状态传递**：JWT 自带签名，网关仅需 secret 即可校验，无需访问数据库，提升了并发性能；
2. **可控的会话管理**：虽然 JWT 无状态，但结合 Redis 存储 `LoginUser` 实现了类似“状态会话”的管理，支持令牌刷新、注销等功能；
3. **安全性**：JWT 不包含敏感信息，仅记录 `userkey`、`userid` 和 `username`，即便泄露也需要配合 Redis 数据才能获取完整权限；同时网关可对签名和过期时间进行校验；
4. **易扩展**：如需增加角色、菜单、租户等信息，只需在登录后存入 `LoginUser` 并缓存到 Redis，下游服务使用时从 Redis 读取即可，无需修改 JWT 结构。

综上所述，本项目的 JWT 方案以 `JwtUtils + TokenService + Redis` 为核心，配合网关过滤器与认证服务，实现了高性能、可控、可扩展的统一身份认证机制。

------

通过以上三个部分的详细讲解，可以看出本项目在全文检索、高并发统计以及 JWT 身份认证方面均采用了相对成熟而清晰的实现方式：全文检索利用 ES 提供的高性能索引与高亮功能，并与微服务数据库结合；高并发统计依托 Redis 的原子操作与定时持久化；JWT 认证方案则在保证无状态传递的同时保留可控的会话管理能力。这些设计思路为构建一个高性能、可扩展的旅行平台提供了坚实基础。